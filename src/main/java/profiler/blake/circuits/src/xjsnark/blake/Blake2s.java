package xjsnark.blake;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import java.math.BigInteger;
import backend.eval.SampleRun;
import backend.auxTypes.UnsignedInteger;
import backend.eval.CircuitEvaluator;

public class Blake2s extends CircuitGenerator {

  public static int numBytesInput;

  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.hexOutputEnabled = true;
    Config.setFiniteFieldModulus(new BigInteger("17855808334804902850260923831770255773646114952324966112694569107431857586177"));
    Config.writeCircuits = true;
    Config.outputFilesPath = args[0];

    numBytesInput = Integer.parseInt(args[1]);

    new Blake2s();
  }

  public Blake2s() {
    super("Blake2s");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        for (int i = 0; i < numBytesInput / 4; i++) {
          m[i].mapValue(BigInteger.valueOf(0x61616161), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
      }
      public void post() {
      }

    });

  }



  public void __init() {
    m = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{numBytesInput / 4}, 32);
  }

  public UnsignedInteger[] m;
  public UnsignedInteger[] digest;

  public static final long[] IV = {1779033703L, 3144134277L, 1013904242L, 2773480762L, 1359893119L, 2600822924L, 528734635L, 1541459225L};
  public static final int[][] SIGMA = new int[][]{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}, {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}, {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4}, {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8}, {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13}, {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9}, {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11}, {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10}, {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5}, {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0}};
  public static final int[] p = new int[]{16842784, 0, 0, 0, 0, 0, 0, 0};
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    m = UnsignedInteger.createInputArray(this, m.length, 32);







  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, digest);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();










  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public void outsource() {
    UnsignedInteger[] h = UnsignedInteger.instantiateFrom(32, IV);
    h[0].assign(h[0].xorBitwise(UnsignedInteger.instantiateFrom(32, p[0])), 32);

    //  One block is 512 bits = 64 bytes 
    int numBlocks = numBytesInput / 64;

    for (int i = 0; i < numBlocks - 1; i++) {
      h = F(h, m, UnsignedInteger.instantiateFrom(64, (i + 1) * 64).copy(64), false, i);
    }

    digest = F(h, m, UnsignedInteger.instantiateFrom(64, numBlocks * 64).copy(64), true, numBlocks - 1);
  }
  public UnsignedInteger[] G(UnsignedInteger[] v, int a, int b, int c, int d, UnsignedInteger x, UnsignedInteger y) {
    int R1 = 16;
    int R2 = 12;
    int R3 = 8;
    int R4 = 7;

    v[a].assign(v[a].add(v[b]).add(x), 32);
    v[d].assign(rotateRight(v[d].xorBitwise(v[a]).copy(32), R1), 32);
    v[c].assign(v[c].add(v[d]), 32);
    v[b].assign(rotateRight(v[b].xorBitwise(v[c]).copy(32), R2), 32);
    v[a].assign(v[a].add(v[b]).add(y), 32);
    v[d].assign(rotateRight(v[d].xorBitwise(v[a]).copy(32), R3), 32);
    v[c].assign(v[c].add(v[d]), 32);
    v[b].assign(rotateRight(v[b].xorBitwise(v[c]).copy(32), R4), 32);

    return v;
  }
  public UnsignedInteger[] F(UnsignedInteger[] h, UnsignedInteger[] m, UnsignedInteger t, boolean f, int block) {
    UnsignedInteger[] v = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);

    for (int j = 0; j < 8; j++) {
      v[j].assign(h[j], 32);
    }
    for (int j = 8; j < 16; j++) {
      v[j].assign(UnsignedInteger.instantiateFrom(32, IV[j - 8]), 32);
    }

    v[12].assign(v[12].xorBitwise(UnsignedInteger.instantiateFrom(32, t)), 32);
    v[13].assign(v[13].xorBitwise(UnsignedInteger.instantiateFrom(32, t.shiftRight(32))), 32);

    if (f) {
      v[14].assign(v[14].invBits(), 32);
    }

    for (int j = 0; j < 10; j++) {
      int[] s = SIGMA[j];
      v = G(v, 0, 4, 8, 12, m[s[0] + block * 16].copy(32), m[s[1] + block * 16].copy(32));
      v = G(v, 1, 5, 9, 13, m[s[2] + block * 16].copy(32), m[s[3] + block * 16].copy(32));
      v = G(v, 2, 6, 10, 14, m[s[4] + block * 16].copy(32), m[s[5] + block * 16].copy(32));
      v = G(v, 3, 7, 11, 15, m[s[6] + block * 16].copy(32), m[s[7] + block * 16].copy(32));

      v = G(v, 0, 5, 10, 15, m[s[8] + block * 16].copy(32), m[s[9] + block * 16].copy(32));
      v = G(v, 1, 6, 11, 12, m[s[10] + block * 16].copy(32), m[s[11] + block * 16].copy(32));
      v = G(v, 2, 7, 8, 13, m[s[12] + block * 16].copy(32), m[s[13] + block * 16].copy(32));
      v = G(v, 3, 4, 9, 14, m[s[14] + block * 16].copy(32), m[s[15] + block * 16].copy(32));
    }

    for (int j = 0; j < 8; j++) {
      h[j].assign(h[j].xorBitwise(v[j]).xorBitwise(v[j + 8]), 32);
    }

    return h;
  }
  public static UnsignedInteger rotateRight(UnsignedInteger in, int r) {
    return (in.shiftRight(r)).orBitwise((in.shiftLeft((32 - r))));
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
